<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Slice99: slice99.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Slice99
   &#160;<span id="projectnumber">0.7.2</span>
   </div>
   <div id="projectbrief">Memory slices for C99</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slice99.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A slice of some array.  
<a href="#details">More...</a></p>

<p><a href="slice99_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlice99.html">Slice99</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice of some array.  <a href="structSlice99.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a29d489b28cf4d2cf56a17a2617990fee"><td class="memItemLeft" align="right" valign="top"><a id="a29d489b28cf4d2cf56a17a2617990fee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a29d489b28cf4d2cf56a17a2617990fee">SLICE99_ASSERT</a>&#160;&#160;&#160;assert</td></tr>
<tr class="memdesc:a29d489b28cf4d2cf56a17a2617990fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>assert</code>. <br /></td></tr>
<tr class="separator:a29d489b28cf4d2cf56a17a2617990fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6e85e51121b718c704bc6f7c16cd7"><td class="memItemLeft" align="right" valign="top"><a id="a4ad6e85e51121b718c704bc6f7c16cd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a4ad6e85e51121b718c704bc6f7c16cd7">SLICE99_MEMCMP</a>&#160;&#160;&#160;memcmp</td></tr>
<tr class="memdesc:a4ad6e85e51121b718c704bc6f7c16cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memcmp</code>. <br /></td></tr>
<tr class="separator:a4ad6e85e51121b718c704bc6f7c16cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7306a32a97b3b8a5f05c7b052618930c"><td class="memItemLeft" align="right" valign="top"><a id="a7306a32a97b3b8a5f05c7b052618930c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a>&#160;&#160;&#160;memcpy</td></tr>
<tr class="memdesc:a7306a32a97b3b8a5f05c7b052618930c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memcpy</code>. <br /></td></tr>
<tr class="separator:a7306a32a97b3b8a5f05c7b052618930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5c9f55ad339be88c60744fadb239f6"><td class="memItemLeft" align="right" valign="top"><a id="afa5c9f55ad339be88c60744fadb239f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#afa5c9f55ad339be88c60744fadb239f6">SLICE99_MEMMOVE</a>&#160;&#160;&#160;memmove</td></tr>
<tr class="memdesc:afa5c9f55ad339be88c60744fadb239f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memmove</code>. <br /></td></tr>
<tr class="separator:afa5c9f55ad339be88c60744fadb239f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ab39995ce273807783bb0006d9d85d"><td class="memItemLeft" align="right" valign="top"><a id="a74ab39995ce273807783bb0006d9d85d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a74ab39995ce273807783bb0006d9d85d">SLICE99_STRLEN</a>&#160;&#160;&#160;strlen</td></tr>
<tr class="memdesc:a74ab39995ce273807783bb0006d9d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strlen</code>. <br /></td></tr>
<tr class="separator:a74ab39995ce273807783bb0006d9d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20d9d653b7c065db03d068ada57b89c"><td class="memItemLeft" align="right" valign="top"><a id="aa20d9d653b7c065db03d068ada57b89c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#aa20d9d653b7c065db03d068ada57b89c">SLICE99_MAJOR</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa20d9d653b7c065db03d068ada57b89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The major version number. <br /></td></tr>
<tr class="separator:aa20d9d653b7c065db03d068ada57b89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a577ef72a4eace6cfb5ca89f2518250"><td class="memItemLeft" align="right" valign="top"><a id="a8a577ef72a4eace6cfb5ca89f2518250"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a8a577ef72a4eace6cfb5ca89f2518250">SLICE99_MINOR</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:a8a577ef72a4eace6cfb5ca89f2518250"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minor version number. <br /></td></tr>
<tr class="separator:a8a577ef72a4eace6cfb5ca89f2518250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910ddb4ba43cb60535cf6d1c3cb498a0"><td class="memItemLeft" align="right" valign="top"><a id="a910ddb4ba43cb60535cf6d1c3cb498a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a910ddb4ba43cb60535cf6d1c3cb498a0">SLICE99_PATCH</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a910ddb4ba43cb60535cf6d1c3cb498a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The patch version number. <br /></td></tr>
<tr class="separator:a910ddb4ba43cb60535cf6d1c3cb498a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557c011352fbc859d6c9ed3871a31c5e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a557c011352fbc859d6c9ed3871a31c5e">SLICE99_DEF_TYPED</a>(name,  T)</td></tr>
<tr class="memdesc:a557c011352fbc859d6c9ed3871a31c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the strongly typed slice <code>name</code> containing items of type <code>T</code>.  <a href="#a557c011352fbc859d6c9ed3871a31c5e">More...</a><br /></td></tr>
<tr class="separator:a557c011352fbc859d6c9ed3871a31c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3a66e2441e671e725b50545328f14d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a3e3a66e2441e671e725b50545328f14d">SLICE99_TO_TYPED</a>(self)&#160;&#160;&#160;{ .ptr = (self).ptr, .len = (self).len }</td></tr>
<tr class="memdesc:a3e3a66e2441e671e725b50545328f14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a> to a typed representation.  <a href="#a3e3a66e2441e671e725b50545328f14d">More...</a><br /></td></tr>
<tr class="separator:a3e3a66e2441e671e725b50545328f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fddbbb1c51ba529d7ca210c4ec4697"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a97fddbbb1c51ba529d7ca210c4ec4697">SLICE99_TO_UNTYPED</a>(self)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a>((self).ptr, sizeof(*(self).ptr), (self).len)</td></tr>
<tr class="memdesc:a97fddbbb1c51ba529d7ca210c4ec4697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the typed slice <code>self</code> to <a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a>.  <a href="#a97fddbbb1c51ba529d7ca210c4ec4697">More...</a><br /></td></tr>
<tr class="separator:a97fddbbb1c51ba529d7ca210c4ec4697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fc375eb1db0b3907825ea0720fbf0c"><td class="memItemLeft" align="right" valign="top"><a id="a36fc375eb1db0b3907825ea0720fbf0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a36fc375eb1db0b3907825ea0720fbf0c">SLICE99_ARRAY_LEN</a>(...)&#160;&#160;&#160;(sizeof(__VA_ARGS__) / sizeof((__VA_ARGS__)[0]))</td></tr>
<tr class="memdesc:a36fc375eb1db0b3907825ea0720fbf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a number of items in an array expression. <br /></td></tr>
<tr class="separator:a36fc375eb1db0b3907825ea0720fbf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9d7971e5940ca105fe84079766c4a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ade9d7971e5940ca105fe84079766c4a9">SLICE99_APPEND</a>(buffer,  obj)&#160;&#160;&#160;((char *)<a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a>((buffer), &amp;(obj), sizeof(obj)) + sizeof(obj))</td></tr>
<tr class="memdesc:ade9d7971e5940ca105fe84079766c4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>obj</code> to <code>buffer</code>, returning the next position of <code>buffer</code> to write to.  <a href="#ade9d7971e5940ca105fe84079766c4a9">More...</a><br /></td></tr>
<tr class="separator:ade9d7971e5940ca105fe84079766c4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602156c96682543a687b6c9d783f7c87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a602156c96682543a687b6c9d783f7c87">SLICE99_APPEND_ARRAY</a>(buffer,  ptr,  len)&#160;&#160;&#160;((char *)<a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a>((buffer), (ptr), sizeof((ptr)[0]) * (len)) + sizeof((ptr)[0]) * (len))</td></tr>
<tr class="memdesc:a602156c96682543a687b6c9d783f7c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the array of length <code>len</code> accessible through <code>ptr</code> into <code>buffer</code>, returning the next position of <code>buffer</code> to write to.  <a href="#a602156c96682543a687b6c9d783f7c87">More...</a><br /></td></tr>
<tr class="separator:a602156c96682543a687b6c9d783f7c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5300ed70f13eda8357c6833e7710a51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#af5300ed70f13eda8357c6833e7710a51">SLICE99_TO_OCTETS</a>(obj)&#160;&#160;&#160;U8Slice99_new((uint8_t *)&amp;(obj), sizeof(obj))</td></tr>
<tr class="memdesc:af5300ed70f13eda8357c6833e7710a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs <code>U8Slice99</code> from <code>obj</code>.  <a href="#af5300ed70f13eda8357c6833e7710a51">More...</a><br /></td></tr>
<tr class="separator:af5300ed70f13eda8357c6833e7710a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee899fa7bd6ee37b88c0bf229213d97e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#aee899fa7bd6ee37b88c0bf229213d97e">Slice99_from_array</a>(...)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a>((void *)(__VA_ARGS__), sizeof((__VA_ARGS__)[0]), <a class="el" href="slice99_8h.html#a36fc375eb1db0b3907825ea0720fbf0c">SLICE99_ARRAY_LEN</a>(__VA_ARGS__))</td></tr>
<tr class="memdesc:aee899fa7bd6ee37b88c0bf229213d97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice from an array expression.  <a href="#aee899fa7bd6ee37b88c0bf229213d97e">More...</a><br /></td></tr>
<tr class="separator:aee899fa7bd6ee37b88c0bf229213d97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ea7b96fe0a7ac510adb7005e863c49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a71ea7b96fe0a7ac510adb7005e863c49">Slice99_typed_from_array</a>(...)&#160;&#160;&#160;{ .ptr = (__VA_ARGS__), .len = <a class="el" href="slice99_8h.html#a36fc375eb1db0b3907825ea0720fbf0c">SLICE99_ARRAY_LEN</a>(__VA_ARGS__) }</td></tr>
<tr class="memdesc:a71ea7b96fe0a7ac510adb7005e863c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#aee899fa7bd6ee37b88c0bf229213d97e" title="Constructs a slice from an array expression. ">Slice99_from_array</a> but for typed slices.  <a href="#a71ea7b96fe0a7ac510adb7005e863c49">More...</a><br /></td></tr>
<tr class="separator:a71ea7b96fe0a7ac510adb7005e863c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c2fd6a232198b3c511c19f3546b41b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#af8c2fd6a232198b3c511c19f3546b41b">Slice99_from_typed_ptr</a>(ptr,  len)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a>(ptr, sizeof(*ptr), len)</td></tr>
<tr class="memdesc:af8c2fd6a232198b3c511c19f3546b41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice from a pointer of a non-<code>void</code> type and a length.  <a href="#af8c2fd6a232198b3c511c19f3546b41b">More...</a><br /></td></tr>
<tr class="separator:af8c2fd6a232198b3c511c19f3546b41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a45e1af2b78b1d2189eddd20214d3c0ad"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a> (void *ptr, size_t item_size, size_t len)</td></tr>
<tr class="memdesc:a45e1af2b78b1d2189eddd20214d3c0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice.  <a href="#a45e1af2b78b1d2189eddd20214d3c0ad">More...</a><br /></td></tr>
<tr class="separator:a45e1af2b78b1d2189eddd20214d3c0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827f21894eb4424d835b93de680caa9e"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a827f21894eb4424d835b93de680caa9e">Slice99_from_str</a> (char *str)</td></tr>
<tr class="memdesc:a827f21894eb4424d835b93de680caa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice from <code>str</code>.  <a href="#a827f21894eb4424d835b93de680caa9e">More...</a><br /></td></tr>
<tr class="separator:a827f21894eb4424d835b93de680caa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ddbf9b09c12cee18c2546c0e08d657"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#af4ddbf9b09c12cee18c2546c0e08d657">Slice99_from_ptrdiff</a> (void *start, void *end, size_t item_size)</td></tr>
<tr class="memdesc:af4ddbf9b09c12cee18c2546c0e08d657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice residing between <code>start</code> (inclusively) and <code>end</code> (exclusively).  <a href="#af4ddbf9b09c12cee18c2546c0e08d657">More...</a><br /></td></tr>
<tr class="separator:af4ddbf9b09c12cee18c2546c0e08d657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab994ee5ddd723fb1f09f77d209466b05"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab994ee5ddd723fb1f09f77d209466b05">Slice99_empty</a> (size_t item_size)</td></tr>
<tr class="memdesc:ab994ee5ddd723fb1f09f77d209466b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty slice.  <a href="#ab994ee5ddd723fb1f09f77d209466b05">More...</a><br /></td></tr>
<tr class="separator:ab994ee5ddd723fb1f09f77d209466b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b671c453b415d9ca3d231626bd73ba0"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a0b671c453b415d9ca3d231626bd73ba0">Slice99_update_len</a> (<a class="el" href="structSlice99.html">Slice99</a> self, size_t new_len)</td></tr>
<tr class="memdesc:a0b671c453b415d9ca3d231626bd73ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>self</code> with the new length <code>new_len</code>.  <a href="#a0b671c453b415d9ca3d231626bd73ba0">More...</a><br /></td></tr>
<tr class="separator:a0b671c453b415d9ca3d231626bd73ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04282a1e8e5522a4b6fbb3f28492367"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ad04282a1e8e5522a4b6fbb3f28492367">Slice99_is_empty</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:ad04282a1e8e5522a4b6fbb3f28492367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>self</code> is empty or not.  <a href="#ad04282a1e8e5522a4b6fbb3f28492367">More...</a><br /></td></tr>
<tr class="separator:ad04282a1e8e5522a4b6fbb3f28492367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1981dc6bf18ca36407f2160846c816"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a2c1981dc6bf18ca36407f2160846c816">Slice99_size</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:a2c1981dc6bf18ca36407f2160846c816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a total size in bytes.  <a href="#a2c1981dc6bf18ca36407f2160846c816">More...</a><br /></td></tr>
<tr class="separator:a2c1981dc6bf18ca36407f2160846c816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844a37ba514d3fc0382972a2fa2a3419"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a844a37ba514d3fc0382972a2fa2a3419">Slice99_get</a> (<a class="el" href="structSlice99.html">Slice99</a> self, ptrdiff_t i)</td></tr>
<tr class="memdesc:a844a37ba514d3fc0382972a2fa2a3419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pointer to the <code>i</code> -indexed item.  <a href="#a844a37ba514d3fc0382972a2fa2a3419">More...</a><br /></td></tr>
<tr class="separator:a844a37ba514d3fc0382972a2fa2a3419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3efecbb56ae6ddf66db72c5fc12c335"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab3efecbb56ae6ddf66db72c5fc12c335">Slice99_first</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:ab3efecbb56ae6ddf66db72c5fc12c335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pointer to the first item.  <a href="#ab3efecbb56ae6ddf66db72c5fc12c335">More...</a><br /></td></tr>
<tr class="separator:ab3efecbb56ae6ddf66db72c5fc12c335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273087c5c7b3bd025dd393f1246143b7"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a273087c5c7b3bd025dd393f1246143b7">Slice99_last</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:a273087c5c7b3bd025dd393f1246143b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pointer to the last item.  <a href="#a273087c5c7b3bd025dd393f1246143b7">More...</a><br /></td></tr>
<tr class="separator:a273087c5c7b3bd025dd393f1246143b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7fd2226d3ed730fb6be0381ca3b4fe"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#afa7fd2226d3ed730fb6be0381ca3b4fe">Slice99_sub</a> (<a class="el" href="structSlice99.html">Slice99</a> self, ptrdiff_t start_idx, ptrdiff_t end_idx)</td></tr>
<tr class="memdesc:afa7fd2226d3ed730fb6be0381ca3b4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subslicing <code>self</code> with [<code>start_idx</code> <code>..</code> <code>end_idx</code>].  <a href="#afa7fd2226d3ed730fb6be0381ca3b4fe">More...</a><br /></td></tr>
<tr class="separator:afa7fd2226d3ed730fb6be0381ca3b4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab364d098941c1f0d6c9316dd845198d3"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab364d098941c1f0d6c9316dd845198d3">Slice99_advance</a> (<a class="el" href="structSlice99.html">Slice99</a> self, ptrdiff_t offset)</td></tr>
<tr class="memdesc:ab364d098941c1f0d6c9316dd845198d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances <code>self</code> by <code>offset</code> items.  <a href="#ab364d098941c1f0d6c9316dd845198d3">More...</a><br /></td></tr>
<tr class="separator:ab364d098941c1f0d6c9316dd845198d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776f924703cf8a4f30804bb2dd82f91e"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a776f924703cf8a4f30804bb2dd82f91e">Slice99_primitive_eq</a> (<a class="el" href="structSlice99.html">Slice99</a> lhs, <a class="el" href="structSlice99.html">Slice99</a> rhs)</td></tr>
<tr class="memdesc:a776f924703cf8a4f30804bb2dd82f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a byte-by-byte comparison of <code>lhs</code> with <code>rhs</code>.  <a href="#a776f924703cf8a4f30804bb2dd82f91e">More...</a><br /></td></tr>
<tr class="separator:a776f924703cf8a4f30804bb2dd82f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a50ec3cf6e8232f1863854ec4c10cd8"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a9a50ec3cf6e8232f1863854ec4c10cd8">Slice99_eq</a> (<a class="el" href="structSlice99.html">Slice99</a> lhs, <a class="el" href="structSlice99.html">Slice99</a> rhs, int(*cmp)(const void *, const void *))</td></tr>
<tr class="memdesc:a9a50ec3cf6e8232f1863854ec4c10cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a comparison of <code>lhs</code> with <code>rhs</code> with a user-supplied comparator.  <a href="#a9a50ec3cf6e8232f1863854ec4c10cd8">More...</a><br /></td></tr>
<tr class="separator:a9a50ec3cf6e8232f1863854ec4c10cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5089ecf9f17b19a9a5f6d4d587721ca1"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a5089ecf9f17b19a9a5f6d4d587721ca1">Slice99_primitive_starts_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> prefix)</td></tr>
<tr class="memdesc:a5089ecf9f17b19a9a5f6d4d587721ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>prefix</code> is a prefix of <code>self</code>, byte-by-byte.  <a href="#a5089ecf9f17b19a9a5f6d4d587721ca1">More...</a><br /></td></tr>
<tr class="separator:a5089ecf9f17b19a9a5f6d4d587721ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab117148890c8538a0a51f456ac99bf66"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab117148890c8538a0a51f456ac99bf66">Slice99_starts_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> prefix, int(*cmp)(const void *, const void *))</td></tr>
<tr class="memdesc:ab117148890c8538a0a51f456ac99bf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>prefix</code> is a prefix of <code>self</code> with a user-supplied comparator.  <a href="#ab117148890c8538a0a51f456ac99bf66">More...</a><br /></td></tr>
<tr class="separator:ab117148890c8538a0a51f456ac99bf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bf868bf051593e87c7d163a09e7a7b"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab9bf868bf051593e87c7d163a09e7a7b">Slice99_primitive_ends_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> postfix)</td></tr>
<tr class="memdesc:ab9bf868bf051593e87c7d163a09e7a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>postfix</code> is a postfix of <code>self</code>, byte-by-byte.  <a href="#ab9bf868bf051593e87c7d163a09e7a7b">More...</a><br /></td></tr>
<tr class="separator:ab9bf868bf051593e87c7d163a09e7a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e81025ab0b6afc55b2e31c6efebcfe5"><td class="memItemLeft" align="right" valign="top">static SLICE99_WARN_UNUSED_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a2e81025ab0b6afc55b2e31c6efebcfe5">Slice99_ends_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> postfix, int(*cmp)(const void *, const void *))</td></tr>
<tr class="memdesc:a2e81025ab0b6afc55b2e31c6efebcfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>postfix</code> is a postfix of <code>self</code> with a user-supplied comparator.  <a href="#a2e81025ab0b6afc55b2e31c6efebcfe5">More...</a><br /></td></tr>
<tr class="separator:a2e81025ab0b6afc55b2e31c6efebcfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0633af9b428c3c28e0476c65c4bb5dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#af0633af9b428c3c28e0476c65c4bb5dc">Slice99_copy</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> other)</td></tr>
<tr class="memdesc:af0633af9b428c3c28e0476c65c4bb5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>other</code> to the beginning of <code>self</code>, byte-by-byte.  <a href="#af0633af9b428c3c28e0476c65c4bb5dc">More...</a><br /></td></tr>
<tr class="separator:af0633af9b428c3c28e0476c65c4bb5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e9856494623751a31202d2f1d94409"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab6e9856494623751a31202d2f1d94409">Slice99_copy_non_overlapping</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> other)</td></tr>
<tr class="memdesc:ab6e9856494623751a31202d2f1d94409"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#af0633af9b428c3c28e0476c65c4bb5dc" title="Copies other to the beginning of self, byte-by-byte. ">Slice99_copy</a> except that <code>self</code> and <code>other</code> must be non-overlapping.  <a href="#ab6e9856494623751a31202d2f1d94409">More...</a><br /></td></tr>
<tr class="separator:ab6e9856494623751a31202d2f1d94409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fcf4b3348c53d782cc5ca280c19105"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a20fcf4b3348c53d782cc5ca280c19105">Slice99_swap</a> (<a class="el" href="structSlice99.html">Slice99</a> self, ptrdiff_t lhs, ptrdiff_t rhs, void *restrict backup)</td></tr>
<tr class="memdesc:a20fcf4b3348c53d782cc5ca280c19105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the <code>lhs</code> -indexed and <code>rhs</code> -indexed items.  <a href="#a20fcf4b3348c53d782cc5ca280c19105">More...</a><br /></td></tr>
<tr class="separator:a20fcf4b3348c53d782cc5ca280c19105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64763843fbfeea0099a7bae8a3fcd941"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a64763843fbfeea0099a7bae8a3fcd941">Slice99_swap_with_slice</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> other, void *restrict backup)</td></tr>
<tr class="memdesc:a64763843fbfeea0099a7bae8a3fcd941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all the items in <code>self</code> with those in <code>other</code>.  <a href="#a64763843fbfeea0099a7bae8a3fcd941">More...</a><br /></td></tr>
<tr class="separator:a64763843fbfeea0099a7bae8a3fcd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4ba9696f12fa0cf82fa018828e9a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a51f4ba9696f12fa0cf82fa018828e9a9">Slice99_reverse</a> (<a class="el" href="structSlice99.html">Slice99</a> self, void *restrict backup)</td></tr>
<tr class="memdesc:a51f4ba9696f12fa0cf82fa018828e9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of items in <code>self</code>.  <a href="#a51f4ba9696f12fa0cf82fa018828e9a9">More...</a><br /></td></tr>
<tr class="separator:a51f4ba9696f12fa0cf82fa018828e9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292232b30f8add259cc03a87e5c96d86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a292232b30f8add259cc03a87e5c96d86">Slice99_split_at</a> (<a class="el" href="structSlice99.html">Slice99</a> self, size_t i, <a class="el" href="structSlice99.html">Slice99</a> *restrict lhs, <a class="el" href="structSlice99.html">Slice99</a> *restrict rhs)</td></tr>
<tr class="memdesc:a292232b30f8add259cc03a87e5c96d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>self</code> into two parts.  <a href="#a292232b30f8add259cc03a87e5c96d86">More...</a><br /></td></tr>
<tr class="separator:a292232b30f8add259cc03a87e5c96d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40720954fa063663c72d2d0e1cc61f3"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab40720954fa063663c72d2d0e1cc61f3">Slice99_c_str</a> (<a class="el" href="structSlice99.html">Slice99</a> self, char out[restrict])</td></tr>
<tr class="memdesc:ab40720954fa063663c72d2d0e1cc61f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>self</code> to <code>out</code> and appends '\0' to the end.  <a href="#ab40720954fa063663c72d2d0e1cc61f3">More...</a><br /></td></tr>
<tr class="separator:ab40720954fa063663c72d2d0e1cc61f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef95ce47528e6bc1cdd6008bee3d0fd"><td class="memItemLeft" align="right" valign="top"><a id="aaef95ce47528e6bc1cdd6008bee3d0fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (CharSlice99, char)</td></tr>
<tr class="separator:aaef95ce47528e6bc1cdd6008bee3d0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15de552b5896118143ec0e3b0930872c"><td class="memItemLeft" align="right" valign="top"><a id="a15de552b5896118143ec0e3b0930872c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (SCharSlice99, signed char)</td></tr>
<tr class="separator:a15de552b5896118143ec0e3b0930872c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261a57c2b4f5a0828c5699f9a0ae7754"><td class="memItemLeft" align="right" valign="top"><a id="a261a57c2b4f5a0828c5699f9a0ae7754"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (UCharSlice99, unsigned char)</td></tr>
<tr class="separator:a261a57c2b4f5a0828c5699f9a0ae7754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d4cfc313435c755a3d8c09192e132"><td class="memItemLeft" align="right" valign="top"><a id="a6a5d4cfc313435c755a3d8c09192e132"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (ShortSlice99, short)</td></tr>
<tr class="separator:a6a5d4cfc313435c755a3d8c09192e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543e3a2fb6e23c2b3fd00e7d911840d4"><td class="memItemLeft" align="right" valign="top"><a id="a543e3a2fb6e23c2b3fd00e7d911840d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (UShortSlice99, unsigned short)</td></tr>
<tr class="separator:a543e3a2fb6e23c2b3fd00e7d911840d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01a114b8bb406ed7e34aad7972884c5"><td class="memItemLeft" align="right" valign="top"><a id="af01a114b8bb406ed7e34aad7972884c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (IntSlice99, int)</td></tr>
<tr class="separator:af01a114b8bb406ed7e34aad7972884c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782fa2b5bfcb5ff238dadfb2220eccc6"><td class="memItemLeft" align="right" valign="top"><a id="a782fa2b5bfcb5ff238dadfb2220eccc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (UIntSlice99, unsigned int)</td></tr>
<tr class="separator:a782fa2b5bfcb5ff238dadfb2220eccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f309d7d15c274d12d4c9e76911cc5b"><td class="memItemLeft" align="right" valign="top"><a id="ad9f309d7d15c274d12d4c9e76911cc5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (LongSlice99, long)</td></tr>
<tr class="separator:ad9f309d7d15c274d12d4c9e76911cc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adced994644bc25ae7466592a5424df45"><td class="memItemLeft" align="right" valign="top"><a id="adced994644bc25ae7466592a5424df45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (ULongSlice99, unsigned long)</td></tr>
<tr class="separator:adced994644bc25ae7466592a5424df45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa066cad8072bda3e49fc3c8be9d110"><td class="memItemLeft" align="right" valign="top"><a id="a5aa066cad8072bda3e49fc3c8be9d110"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (LongLongSlice99, long long)</td></tr>
<tr class="separator:a5aa066cad8072bda3e49fc3c8be9d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1284e0a7177787767e9f64857935c2ce"><td class="memItemLeft" align="right" valign="top"><a id="a1284e0a7177787767e9f64857935c2ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (ULongLongSlice99, unsigned long long)</td></tr>
<tr class="separator:a1284e0a7177787767e9f64857935c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200bdb65f49fe08ca7bf43ff7f21c8a"><td class="memItemLeft" align="right" valign="top"><a id="a4200bdb65f49fe08ca7bf43ff7f21c8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (FloatSlice99, float)</td></tr>
<tr class="separator:a4200bdb65f49fe08ca7bf43ff7f21c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed38785df6ec88397fc6da28bca50ee"><td class="memItemLeft" align="right" valign="top"><a id="aeed38785df6ec88397fc6da28bca50ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (DoubleSlice99, double)</td></tr>
<tr class="separator:aeed38785df6ec88397fc6da28bca50ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a91399e836f85186eefc0311cff54fb"><td class="memItemLeft" align="right" valign="top"><a id="a3a91399e836f85186eefc0311cff54fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (LongDoubleSlice99, long double)</td></tr>
<tr class="separator:a3a91399e836f85186eefc0311cff54fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b090b9a8a1a8e427fb509f4a54e2f6"><td class="memItemLeft" align="right" valign="top"><a id="ab3b090b9a8a1a8e427fb509f4a54e2f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (BoolSlice99, _Bool)</td></tr>
<tr class="separator:ab3b090b9a8a1a8e427fb509f4a54e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159044543aeb6c83802e9a5f53b9a0aa"><td class="memItemLeft" align="right" valign="top"><a id="a159044543aeb6c83802e9a5f53b9a0aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (U8Slice99, uint8_t)</td></tr>
<tr class="separator:a159044543aeb6c83802e9a5f53b9a0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987cc6c85325f0e0c7162f9150e3d4ef"><td class="memItemLeft" align="right" valign="top"><a id="a987cc6c85325f0e0c7162f9150e3d4ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (U16Slice99, uint16_t)</td></tr>
<tr class="separator:a987cc6c85325f0e0c7162f9150e3d4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa23bbee16beb581ec1837ce0ec85934"><td class="memItemLeft" align="right" valign="top"><a id="afa23bbee16beb581ec1837ce0ec85934"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (U32Slice99, uint32_t)</td></tr>
<tr class="separator:afa23bbee16beb581ec1837ce0ec85934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc32e4df51e3c7b7b19805327d10dff"><td class="memItemLeft" align="right" valign="top"><a id="abdc32e4df51e3c7b7b19805327d10dff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (U64Slice99, uint64_t)</td></tr>
<tr class="separator:abdc32e4df51e3c7b7b19805327d10dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ac0b168c6bb03aa4a89016ec00870a"><td class="memItemLeft" align="right" valign="top"><a id="a29ac0b168c6bb03aa4a89016ec00870a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (I8Slice99, int8_t)</td></tr>
<tr class="separator:a29ac0b168c6bb03aa4a89016ec00870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8110a7cbd8b066cf6a75d0300b689d"><td class="memItemLeft" align="right" valign="top"><a id="afc8110a7cbd8b066cf6a75d0300b689d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (I16Slice99, int16_t)</td></tr>
<tr class="separator:afc8110a7cbd8b066cf6a75d0300b689d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32eb6433bfeb8d63f6caa6a80cd7048"><td class="memItemLeft" align="right" valign="top"><a id="aa32eb6433bfeb8d63f6caa6a80cd7048"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (I32Slice99, int32_t)</td></tr>
<tr class="separator:aa32eb6433bfeb8d63f6caa6a80cd7048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957ba8c933f170d5286e0694600336a7"><td class="memItemLeft" align="right" valign="top"><a id="a957ba8c933f170d5286e0694600336a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SLICE99_DEF_TYPED</b> (I64Slice99, int64_t)</td></tr>
<tr class="separator:a957ba8c933f170d5286e0694600336a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cbc4ab1aea40d209320bbf4f163104"><td class="memItemLeft" align="right" valign="top"><a id="a27cbc4ab1aea40d209320bbf4f163104"></a>
static SLICE99_WARN_UNUSED_RESULT CharSlice99&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a27cbc4ab1aea40d209320bbf4f163104">CharSlice99_from_str</a> (char *str)</td></tr>
<tr class="memdesc:a27cbc4ab1aea40d209320bbf4f163104"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#a827f21894eb4424d835b93de680caa9e" title="Constructs a slice from str. ">Slice99_from_str</a>. <br /></td></tr>
<tr class="separator:a27cbc4ab1aea40d209320bbf4f163104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6975ebc21476bb4a1eff57e1976e62"><td class="memItemLeft" align="right" valign="top"><a id="a7c6975ebc21476bb4a1eff57e1976e62"></a>
static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a7c6975ebc21476bb4a1eff57e1976e62">CharSlice99_c_str</a> (CharSlice99 self, char out[restrict])</td></tr>
<tr class="memdesc:a7c6975ebc21476bb4a1eff57e1976e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#ab40720954fa063663c72d2d0e1cc61f3" title="Copies self to out and appends &#39;\0&#39; to the end. ">Slice99_c_str</a>. <br /></td></tr>
<tr class="separator:a7c6975ebc21476bb4a1eff57e1976e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A slice of some array. </p>
<p>The macros <a class="el" href="slice99_8h.html#a29d489b28cf4d2cf56a17a2617990fee" title="Like assert. ">SLICE99_ASSERT</a>, <a class="el" href="slice99_8h.html#a4ad6e85e51121b718c704bc6f7c16cd7" title="Like memcmp. ">SLICE99_MEMCMP</a>, <a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c" title="Like memcpy. ">SLICE99_MEMCPY</a>, <a class="el" href="slice99_8h.html#afa5c9f55ad339be88c60744fadb239f6" title="Like memmove. ">SLICE99_MEMMOVE</a>, and <a class="el" href="slice99_8h.html#a74ab39995ce273807783bb0006d9d85d" title="Like strlen. ">SLICE99_STRLEN</a> are automatically defined in case they have not been defined before including this header file. They represent the corresponding standard library's functions, although actual implementations can differ. If you develop software for a freestanding environment, these macros must be defined beforehand. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ade9d7971e5940ca105fe84079766c4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9d7971e5940ca105fe84079766c4a9">&#9670;&nbsp;</a></span>SLICE99_APPEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLICE99_APPEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">obj&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((char *)<a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a>((buffer), &amp;(obj), sizeof(obj)) + sizeof(obj))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>obj</code> to <code>buffer</code>, returning the next position of <code>buffer</code> to write to. </p>
<p>This macro is no different from <code>memcpy</code> except for the return value. It is useful when you want to write a sequence of objects to some memory buffer, e.g., to a packet header:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> uint16_t x = 123;</div><div class="line"><span class="keyword">const</span> uint32_t y = 456;</div><div class="line"></div><div class="line">header = <a class="code" href="slice99_8h.html#ade9d7971e5940ca105fe84079766c4a9">SLICE99_APPEND</a>(header, x);</div><div class="line">header = <a class="code" href="slice99_8h.html#ade9d7971e5940ca105fe84079766c4a9">SLICE99_APPEND</a>(header, y);</div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The memory area to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object (lvalue) that will be copied to <code>buffer</code>, byte-by-byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(char *)buffer + sizeof(obj)</code></dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>buffer</code> must be capable of holding at least <code>sizeof(obj)</code> bytes. </dd>
<dd>
<code>buffer</code> and <code>obj</code> must be non-overlapping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="slice99_8h.html#a602156c96682543a687b6c9d783f7c87" title="Copies the array of length len accessible through ptr into buffer, returning the next position of buf...">SLICE99_APPEND_ARRAY</a> </dd></dl>

</div>
</div>
<a id="a602156c96682543a687b6c9d783f7c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602156c96682543a687b6c9d783f7c87">&#9670;&nbsp;</a></span>SLICE99_APPEND_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLICE99_APPEND_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">buffer, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((char *)<a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a>((buffer), (ptr), sizeof((ptr)[0]) * (len)) + sizeof((ptr)[0]) * (len))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the array of length <code>len</code> accessible through <code>ptr</code> into <code>buffer</code>, returning the next position of <code>buffer</code> to write to. </p>
<p>This function has the same requirements and a return value as of <a class="el" href="slice99_8h.html#ade9d7971e5940ca105fe84079766c4a9" title="Copies obj to buffer, returning the next position of buffer to write to. ">SLICE99_APPEND</a>. </p>

</div>
</div>
<a id="a557c011352fbc859d6c9ed3871a31c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557c011352fbc859d6c9ed3871a31c5e">&#9670;&nbsp;</a></span>SLICE99_DEF_TYPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLICE99_DEF_TYPED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the strongly typed slice <code>name</code> containing items of type <code>T</code>. </p>
<p>This macro defines</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    T *ptr;</div><div class="line">    <span class="keywordtype">size_t</span> len;</div><div class="line">} name;</div></div><!-- fragment --><p>Also, it specialises all the functions operating on <a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a>. Every function (except for <a class="el" href="slice99_8h.html#a827f21894eb4424d835b93de680caa9e" title="Constructs a slice from str. ">Slice99_from_str</a> and <a class="el" href="slice99_8h.html#ab40720954fa063663c72d2d0e1cc61f3" title="Copies self to out and appends &#39;\0&#39; to the end. ">Slice99_c_str</a>) is defined by the following rules:</p>
<ul>
<li>A function named <code>Slice99_*</code> becomes <code>name_*</code>.</li>
<li><code>void *</code> is replaced by <code>T *</code>.</li>
<li><code><a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a></code> is replaced by <code>name</code>.</li>
<li><code>size_t item_size</code> parameters are removed (e.g., as in <a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad" title="Constructs a slice. ">Slice99_new</a>, <a class="el" href="slice99_8h.html#ab994ee5ddd723fb1f09f77d209466b05" title="Constructs an empty slice. ">Slice99_empty</a>, <a class="el" href="slice99_8h.html#af4ddbf9b09c12cee18c2546c0e08d657" title="Constructs a slice residing between start (inclusively) and end (exclusively). ">Slice99_from_ptrdiff</a>).</li>
<li>All function preconditions, invariants, and postconditions remain the same.</li>
</ul>
<p><a class="el" href="slice99_8h.html#a827f21894eb4424d835b93de680caa9e" title="Constructs a slice from str. ">Slice99_from_str</a> and <a class="el" href="slice99_8h.html#ab40720954fa063663c72d2d0e1cc61f3" title="Copies self to out and appends &#39;\0&#39; to the end. ">Slice99_c_str</a> are derived only for <code>CharSlice99</code>.</p>
<h1>Examples</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slice99_8h.html">slice99.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    <span class="keywordtype">double</span> x, y;</div><div class="line">} Point;</div><div class="line"></div><div class="line"><a class="code" href="slice99_8h.html#a557c011352fbc859d6c9ed3871a31c5e">SLICE99_DEF_TYPED</a>(MyPoints, Point);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    MyPoints points = (MyPoints)<a class="code" href="slice99_8h.html#a71ea7b96fe0a7ac510adb7005e863c49">Slice99_typed_from_array</a>(</div><div class="line">        (Point[]){{1.5, 32.5}, {12.0, 314.01}, {-134.10, -9.3}});</div><div class="line"></div><div class="line">    MyPoints first_two = MyPoints_sub(points, 0, 2);</div><div class="line">    Point *first = MyPoints_first(points);</div><div class="line">    <span class="keywordtype">bool</span> is_empty = MyPoints_is_empty(points);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="aee899fa7bd6ee37b88c0bf229213d97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee899fa7bd6ee37b88c0bf229213d97e">&#9670;&nbsp;</a></span>Slice99_from_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_from_array</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a>((void *)(__VA_ARGS__), sizeof((__VA_ARGS__)[0]), <a class="el" href="slice99_8h.html#a36fc375eb1db0b3907825ea0720fbf0c">SLICE99_ARRAY_LEN</a>(__VA_ARGS__))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a slice from an array expression. </p>
<p>The resulting slice will have <a class="el" href="structSlice99.html#af8b9efd5077f389a79eb0e902868ca1b" title="The count of items in the array addressed by ptr. ">Slice99.len</a> equal to the number of items in the array, and <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99.item_size</a> equal to the size of each item. </p>

</div>
</div>
<a id="af8c2fd6a232198b3c511c19f3546b41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c2fd6a232198b3c511c19f3546b41b">&#9670;&nbsp;</a></span>Slice99_from_typed_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_from_typed_ptr</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a>(ptr, sizeof(*ptr), len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a slice from a pointer of a non-<code>void</code> type and a length. </p>
<p>It is equivalent to <a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad" title="Constructs a slice. ">Slice99_new</a> but it automatically computes an item size as <code>sizeof(*ptr)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The pointer of the resulting slice. Must not point to <code>void</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length of the resulting slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5300ed70f13eda8357c6833e7710a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5300ed70f13eda8357c6833e7710a51">&#9670;&nbsp;</a></span>SLICE99_TO_OCTETS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLICE99_TO_OCTETS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">obj</td><td>)</td>
          <td>&#160;&#160;&#160;U8Slice99_new((uint8_t *)&amp;(obj), sizeof(obj))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs <code>U8Slice99</code> from <code>obj</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object (lvalue) to which the resulting slice will point to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An octet slice pointing to <code>obj</code> of length <code>sizeof(obj)</code>. </dd></dl>

</div>
</div>
<a id="a3e3a66e2441e671e725b50545328f14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3a66e2441e671e725b50545328f14d">&#9670;&nbsp;</a></span>SLICE99_TO_TYPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLICE99_TO_TYPED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self</td><td>)</td>
          <td>&#160;&#160;&#160;{ .ptr = (self).ptr, .len = (self).len }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a> to a typed representation. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>self</code> must be an expression of type <a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a>.</dd></dl>
<h1>Examples</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slice99_8h.html">slice99.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="structSlice99.html">Slice99</a> x = <a class="code" href="slice99_8h.html#a827f21894eb4424d835b93de680caa9e">Slice99_from_str</a>(<span class="stringliteral">&quot;abc&quot;</span>);</div><div class="line">    CharSlice99 y = (CharSlice99)<a class="code" href="slice99_8h.html#a3e3a66e2441e671e725b50545328f14d">SLICE99_TO_TYPED</a>(x);</div><div class="line">    (void)y;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a97fddbbb1c51ba529d7ca210c4ec4697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fddbbb1c51ba529d7ca210c4ec4697">&#9670;&nbsp;</a></span>SLICE99_TO_UNTYPED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SLICE99_TO_UNTYPED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a45e1af2b78b1d2189eddd20214d3c0ad">Slice99_new</a>((self).ptr, sizeof(*(self).ptr), (self).len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the typed slice <code>self</code> to <a class="el" href="structSlice99.html" title="A slice of some array. ">Slice99</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>self</code> must be an expression of type defined by <a class="el" href="slice99_8h.html#a557c011352fbc859d6c9ed3871a31c5e" title="Defines the strongly typed slice name containing items of type T. ">SLICE99_DEF_TYPED</a>.</dd></dl>
<h1>Examples</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slice99_8h.html">slice99.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    CharSlice99 x = <a class="code" href="slice99_8h.html#a27cbc4ab1aea40d209320bbf4f163104">CharSlice99_from_str</a>(<span class="stringliteral">&quot;abc&quot;</span>);</div><div class="line">    <a class="code" href="structSlice99.html">Slice99</a> y = <a class="code" href="slice99_8h.html#a97fddbbb1c51ba529d7ca210c4ec4697">SLICE99_TO_UNTYPED</a>(x);</div><div class="line">    (void)y;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a71ea7b96fe0a7ac510adb7005e863c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ea7b96fe0a7ac510adb7005e863c49">&#9670;&nbsp;</a></span>Slice99_typed_from_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_typed_from_array</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;{ .ptr = (__VA_ARGS__), .len = <a class="el" href="slice99_8h.html#a36fc375eb1db0b3907825ea0720fbf0c">SLICE99_ARRAY_LEN</a>(__VA_ARGS__) }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The same as <a class="el" href="slice99_8h.html#aee899fa7bd6ee37b88c0bf229213d97e" title="Constructs a slice from an array expression. ">Slice99_from_array</a> but for typed slices. </p>
<h1>Examples</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slice99_8h.html">slice99.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>) {</div><div class="line">    IntSlice99 x = (IntSlice99)<a class="code" href="slice99_8h.html#a71ea7b96fe0a7ac510adb7005e863c49">Slice99_typed_from_array</a>((<span class="keywordtype">int</span>[]){1, 2, 3});</div><div class="line">    (void)x;</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab364d098941c1f0d6c9316dd845198d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab364d098941c1f0d6c9316dd845198d3">&#9670;&nbsp;</a></span>Slice99_advance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances <code>self</code> by <code>offset</code> items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The original slice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The number of items to advance. Can be negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice advanced by <code>offset</code> items.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>offset &lt;= (self).len</code> </dd>
<dd>
<code>self.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="ab40720954fa063663c72d2d0e1cc61f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40720954fa063663c72d2d0e1cc61f3">&#9670;&nbsp;</a></span>Slice99_c_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* Slice99_c_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>out</em>[restrict]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies <code>self</code> to <code>out</code> and appends '\0' to the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice that will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>The memory area to which <code>self</code> and the null character will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer <code>out</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>out</code> must be capable of writing <code>Slice99_size(self) + 1</code> bytes. </dd>
<dd>
<code>out</code> must not overlap with <code>self</code>. </dd></dl>

</div>
</div>
<a id="af0633af9b428c3c28e0476c65c4bb5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0633af9b428c3c28e0476c65c4bb5dc">&#9670;&nbsp;</a></span>Slice99_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies <code>other</code> to the beginning of <code>self</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The location to which the whole <code>other</code> will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The slice to be copied to <code>self</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6e9856494623751a31202d2f1d94409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e9856494623751a31202d2f1d94409">&#9670;&nbsp;</a></span>Slice99_copy_non_overlapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_copy_non_overlapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="slice99_8h.html#af0633af9b428c3c28e0476c65c4bb5dc" title="Copies other to the beginning of self, byte-by-byte. ">Slice99_copy</a> except that <code>self</code> and <code>other</code> must be non-overlapping. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>self</code> and <code>other</code> must be non-overlapping. </dd></dl>

</div>
</div>
<a id="ab994ee5ddd723fb1f09f77d209466b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab994ee5ddd723fb1f09f77d209466b05">&#9670;&nbsp;</a></span>Slice99_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_empty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>The value of <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99::item_size</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>item_size &gt; 0</code> </dd></dl>

</div>
</div>
<a id="a2e81025ab0b6afc55b2e31c6efebcfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e81025ab0b6afc55b2e31c6efebcfe5">&#9670;&nbsp;</a></span>Slice99_ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT bool Slice99_ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>postfix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>postfix</code> is a postfix of <code>self</code> with a user-supplied comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>postfix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">postfix</td><td>The slice to be checked whether it is a postfix of <code>self</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>The function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>postfix</code> is a postfix of <code>self</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.item_size == postfix.item_size</code> </dd>
<dd>
<code>cmp != NULL</code> </dd>
<dd>
<code>self.len</code> and <code>postfix.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="a9a50ec3cf6e8232f1863854ec4c10cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a50ec3cf6e8232f1863854ec4c10cd8">&#9670;&nbsp;</a></span>Slice99_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT bool Slice99_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a comparison of <code>lhs</code> with <code>rhs</code> with a user-supplied comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The first slice to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The second slice to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>The function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> and <code>rhs</code> are equal, <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>lhs.item_size == rhs.item_size</code> </dd>
<dd>
<code>cmp != NULL</code> </dd>
<dd>
<code>lhs.len</code> and <code>rhs.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="ab3efecbb56ae6ddf66db72c5fc12c335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3efecbb56ae6ddf66db72c5fc12c335">&#9670;&nbsp;</a></span>Slice99_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST void* Slice99_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a pointer to the first item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice upon which the pointer will be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4ddbf9b09c12cee18c2546c0e08d657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ddbf9b09c12cee18c2546c0e08d657">&#9670;&nbsp;</a></span>Slice99_from_ptrdiff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_from_ptrdiff </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a slice residing between <code>start</code> (inclusively) and <code>end</code> (exclusively). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start position of a returned slice, inclusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end position of a returned slice, exlusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>The value of <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99::item_size</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>start != NULL</code> </dd>
<dd>
<code>end != NULL</code> </dd>
<dd>
<code>((char *)end - (char *)start) &gt;= 0</code> </dd>
<dd>
<code>(((char *)end - (char *)start)) % item_size == 0</code> </dd></dl>

</div>
</div>
<a id="a827f21894eb4424d835b93de680caa9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827f21894eb4424d835b93de680caa9e">&#9670;&nbsp;</a></span>Slice99_from_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_from_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a slice from <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Any null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>str != NULL</code> </dd></dl>

</div>
</div>
<a id="a844a37ba514d3fc0382972a2fa2a3419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844a37ba514d3fc0382972a2fa2a3419">&#9670;&nbsp;</a></span>Slice99_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST void* Slice99_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a pointer to the <code>i</code> -indexed item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice upon which the pointer will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of a desired item. Can be negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.item_size</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="ad04282a1e8e5522a4b6fbb3f28492367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04282a1e8e5522a4b6fbb3f28492367">&#9670;&nbsp;</a></span>Slice99_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST bool Slice99_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>self</code> is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The checked slice.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>self</code> is empty, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a273087c5c7b3bd025dd393f1246143b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273087c5c7b3bd025dd393f1246143b7">&#9670;&nbsp;</a></span>Slice99_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST void* Slice99_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a pointer to the last item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice upon which the pointer will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="a45e1af2b78b1d2189eddd20214d3c0ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e1af2b78b1d2189eddd20214d3c0ad">&#9670;&nbsp;</a></span>Slice99_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_new </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The value of <a class="el" href="structSlice99.html#a1e583c6b18eb901fbe18a7872528c097" title="The pointer to data. ">Slice99::ptr</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>The value of <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99::item_size</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The value of <a class="el" href="structSlice99.html#af8b9efd5077f389a79eb0e902868ca1b" title="The count of items in the array addressed by ptr. ">Slice99::len</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>ptr != NULL</code> </dd>
<dd>
<code>item_size &gt; 0</code> </dd></dl>

</div>
</div>
<a id="ab9bf868bf051593e87c7d163a09e7a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bf868bf051593e87c7d163a09e7a7b">&#9670;&nbsp;</a></span>Slice99_primitive_ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT bool Slice99_primitive_ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>postfix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>postfix</code> is a postfix of <code>self</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>postfix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">postfix</td><td>The slice to be checked whether it is a postfix of <code>self</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>postfix</code> is a postfix of <code>self</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.len</code> and <code>postfix.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="a776f924703cf8a4f30804bb2dd82f91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776f924703cf8a4f30804bb2dd82f91e">&#9670;&nbsp;</a></span>Slice99_primitive_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT bool Slice99_primitive_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a byte-by-byte comparison of <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The first slice to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The second slice to be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> and <code>rhs</code> are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5089ecf9f17b19a9a5f6d4d587721ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5089ecf9f17b19a9a5f6d4d587721ca1">&#9670;&nbsp;</a></span>Slice99_primitive_starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT bool Slice99_primitive_starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>prefix</code> is a prefix of <code>self</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>prefix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The slice to be checked whether it is a prefix of <code>self</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>prefix</code> is a prefix of <code>self</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>prefix.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="a51f4ba9696f12fa0cf82fa018828e9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f4ba9696f12fa0cf82fa018828e9a9">&#9670;&nbsp;</a></span>Slice99_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of items in <code>self</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The slice to be reversed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>The memory area of <code>self.item_size</code> bytes accessible for reading and writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>backup != NULL</code> </dd>
<dd>
<code>self.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="a2c1981dc6bf18ca36407f2160846c816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1981dc6bf18ca36407f2160846c816">&#9670;&nbsp;</a></span>Slice99_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT SLICE99_CONST size_t Slice99_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a total size in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice whose size is to be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a292232b30f8add259cc03a87e5c96d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292232b30f8add259cc03a87e5c96d86">&#9670;&nbsp;</a></span>Slice99_split_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a> *restrict&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a> *restrict&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>self</code> into two parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be splitted into <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index at which <code>self</code> will be splitted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lhs</td><td>The first part of <code>self</code> indexed as [0; <code>i</code>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhs</td><td>The second part of <code>self</code> indexed as [<code>i</code>; <code>self.len</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>i &lt;= self.len</code> </dd>
<dd>
<code>lhs != NULL</code> </dd>
<dd>
<code>rhs != NULL</code> </dd>
<dd>
<code>self.len</code> and <code>i</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="ab117148890c8538a0a51f456ac99bf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab117148890c8538a0a51f456ac99bf66">&#9670;&nbsp;</a></span>Slice99_starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT bool Slice99_starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>prefix</code> is a prefix of <code>self</code> with a user-supplied comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>prefix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The slice to be checked whether it is a prefix of <code>self</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp</td><td>The function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>prefix</code> is a prefix of <code>self</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.item_size == prefix.item_size</code> </dd>
<dd>
<code>cmp != NULL</code> </dd>
<dd>
<code>prefix.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="afa7fd2226d3ed730fb6be0381ca3b4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7fd2226d3ed730fb6be0381ca3b4fe">&#9670;&nbsp;</a></span>Slice99_sub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>start_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>end_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subslicing <code>self</code> with [<code>start_idx</code> <code>..</code> <code>end_idx</code>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The original slice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_idx</td><td>The index at which a new slice will reside, inclusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_idx</td><td>The index at which a new slice will end, exclusively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice with the aforementioned properties.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>start_idx &lt;= end_idx</code> </dd></dl>

</div>
</div>
<a id="a20fcf4b3348c53d782cc5ca280c19105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fcf4b3348c53d782cc5ca280c19105">&#9670;&nbsp;</a></span>Slice99_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the <code>lhs</code> -indexed and <code>rhs</code> -indexed items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The slice in which <code>lhs</code> and <code>rhs</code> will be swapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The index of the first item. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The index of the second item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>The memory area of <code>self.item_size</code> bytes accessible for reading and writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>backup != NULL</code> </dd>
<dd>
<code>backup</code> must not overlap with <code>Slice99_get(self, lhs)</code> and <code>Slice99_get(self, rhs)</code>. </dd>
<dd>
<code>Slice99_get(self, lhs)</code> and <code>Slice99_get(self, rhs)</code> must not overlap. </dd></dl>

</div>
</div>
<a id="a64763843fbfeea0099a7bae8a3fcd941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64763843fbfeea0099a7bae8a3fcd941">&#9670;&nbsp;</a></span>Slice99_swap_with_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_swap_with_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all the items in <code>self</code> with those in <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The first slice to be swapped. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">other</td><td>The second slice to be swapped. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>The memory area of <code>self.item_size</code> bytes accessible for reading and writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.len == other.len</code> </dd>
<dd>
<code>self.item_size == other.item_size</code> </dd>
<dd>
<code>backup</code> must not overlap with <code>self</code> and <code>other</code>. </dd>
<dd>
<code>self</code> and <code>other</code> must not overlap. </dd>
<dd>
<code>self.len</code> must be representable as <code>ptrdiff_t</code>. </dd></dl>

</div>
</div>
<a id="a0b671c453b415d9ca3d231626bd73ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b671c453b415d9ca3d231626bd73ba0">&#9670;&nbsp;</a></span>Slice99_update_len()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SLICE99_WARN_UNUSED_RESULT <a class="el" href="structSlice99.html">Slice99</a> Slice99_update_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates <code>self</code> with the new length <code>new_len</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice whose length will be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_len</td><td>The new length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
