<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>slice99: slice99.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">slice99
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Array slicing for C99</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">slice99.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A slice of some array.  
<a href="#details">More...</a></p>

<p><a href="slice99_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSlice99.html">Slice99</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slice of some array.  <a href="structSlice99.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a29d489b28cf4d2cf56a17a2617990fee"><td class="memItemLeft" align="right" valign="top"><a id="a29d489b28cf4d2cf56a17a2617990fee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a29d489b28cf4d2cf56a17a2617990fee">SLICE99_ASSERT</a>&#160;&#160;&#160;assert</td></tr>
<tr class="memdesc:a29d489b28cf4d2cf56a17a2617990fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>assert</code>. <br /></td></tr>
<tr class="separator:a29d489b28cf4d2cf56a17a2617990fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6e85e51121b718c704bc6f7c16cd7"><td class="memItemLeft" align="right" valign="top"><a id="a4ad6e85e51121b718c704bc6f7c16cd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a4ad6e85e51121b718c704bc6f7c16cd7">SLICE99_MEMCMP</a>&#160;&#160;&#160;memcmp</td></tr>
<tr class="memdesc:a4ad6e85e51121b718c704bc6f7c16cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memcmp</code>. <br /></td></tr>
<tr class="separator:a4ad6e85e51121b718c704bc6f7c16cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7306a32a97b3b8a5f05c7b052618930c"><td class="memItemLeft" align="right" valign="top"><a id="a7306a32a97b3b8a5f05c7b052618930c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a>&#160;&#160;&#160;memcpy</td></tr>
<tr class="memdesc:a7306a32a97b3b8a5f05c7b052618930c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memcpy</code>. <br /></td></tr>
<tr class="separator:a7306a32a97b3b8a5f05c7b052618930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5c9f55ad339be88c60744fadb239f6"><td class="memItemLeft" align="right" valign="top"><a id="afa5c9f55ad339be88c60744fadb239f6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#afa5c9f55ad339be88c60744fadb239f6">SLICE99_MEMMOVE</a>&#160;&#160;&#160;memmove</td></tr>
<tr class="memdesc:afa5c9f55ad339be88c60744fadb239f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memmove</code>. <br /></td></tr>
<tr class="separator:afa5c9f55ad339be88c60744fadb239f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ab39995ce273807783bb0006d9d85d"><td class="memItemLeft" align="right" valign="top"><a id="a74ab39995ce273807783bb0006d9d85d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a74ab39995ce273807783bb0006d9d85d">SLICE99_STRLEN</a>&#160;&#160;&#160;strlen</td></tr>
<tr class="memdesc:a74ab39995ce273807783bb0006d9d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strlen</code>. <br /></td></tr>
<tr class="separator:a74ab39995ce273807783bb0006d9d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75364d1b179202146fcf2953356d01a"><td class="memItemLeft" align="right" valign="top"><a id="af75364d1b179202146fcf2953356d01a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#af75364d1b179202146fcf2953356d01a">SLICE99_QSORT</a>&#160;&#160;&#160;qsort</td></tr>
<tr class="memdesc:af75364d1b179202146fcf2953356d01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>qsort</code>. <br /></td></tr>
<tr class="separator:af75364d1b179202146fcf2953356d01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedee03b3135514dfcbdf244d01fa4d35"><td class="memItemLeft" align="right" valign="top"><a id="aedee03b3135514dfcbdf244d01fa4d35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#aedee03b3135514dfcbdf244d01fa4d35">SLICE99_BSEARCH</a>&#160;&#160;&#160;bsearch</td></tr>
<tr class="memdesc:aedee03b3135514dfcbdf244d01fa4d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>bsearch</code>. <br /></td></tr>
<tr class="separator:aedee03b3135514dfcbdf244d01fa4d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c76760ffa8f1b96400c17539684c6da"><td class="memItemLeft" align="right" valign="top"><a id="a2c76760ffa8f1b96400c17539684c6da"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a2c76760ffa8f1b96400c17539684c6da">Slice99_array_len</a>(...)&#160;&#160;&#160;(sizeof(__VA_ARGS__) / sizeof((__VA_ARGS__)[0]))</td></tr>
<tr class="memdesc:a2c76760ffa8f1b96400c17539684c6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a number of items in an array expression. <br /></td></tr>
<tr class="separator:a2c76760ffa8f1b96400c17539684c6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee899fa7bd6ee37b88c0bf229213d97e"><td class="memItemLeft" align="right" valign="top"><a id="aee899fa7bd6ee37b88c0bf229213d97e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#aee899fa7bd6ee37b88c0bf229213d97e">Slice99_from_array</a>(...)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a2b245f73d9eb540878d9b09c286c7a5d">Slice99_new</a>((void *)(__VA_ARGS__), sizeof((__VA_ARGS__)[0]), <a class="el" href="slice99_8h.html#a2c76760ffa8f1b96400c17539684c6da">Slice99_array_len</a>(__VA_ARGS__))</td></tr>
<tr class="memdesc:aee899fa7bd6ee37b88c0bf229213d97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice from an array expression. <br /></td></tr>
<tr class="separator:aee899fa7bd6ee37b88c0bf229213d97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907b544bdd92e9d7a7b3b50c69102fd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6">Slice99_get</a>(self,  i)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a80df197030d2e328a1856a68204b7c0b">Slice99_get_cast_type</a>(self, i, size_t)</td></tr>
<tr class="memdesc:a907b544bdd92e9d7a7b3b50c69102fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pointer to the <code>i</code> -indexed item.  <a href="#a907b544bdd92e9d7a7b3b50c69102fd6">More...</a><br /></td></tr>
<tr class="separator:a907b544bdd92e9d7a7b3b50c69102fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80df197030d2e328a1856a68204b7c0b"><td class="memItemLeft" align="right" valign="top"><a id="a80df197030d2e328a1856a68204b7c0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a80df197030d2e328a1856a68204b7c0b">Slice99_get_cast_type</a>(self,  i,  T)&#160;&#160;&#160;((void *)((char *)(self).ptr + ((i) * (T)(self).item_size)))</td></tr>
<tr class="memdesc:a80df197030d2e328a1856a68204b7c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6" title="Computes a pointer to the i -indexed item. ">Slice99_get</a> but explicitly casts <code>(self).item_size</code> to <code>T</code>. <br /></td></tr>
<tr class="separator:a80df197030d2e328a1856a68204b7c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c941abce41d90462e745ef6729e8965"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a2c941abce41d90462e745ef6729e8965">Slice99_sub</a>(self,  start_idx,  end_idx)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#aff5368fbf40b74b98e7f24de59596e8c">Slice99_sub_cast_type</a>(self, start_idx, end_idx, size_t)</td></tr>
<tr class="memdesc:a2c941abce41d90462e745ef6729e8965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subslicing <code>self</code> with [<code>start_idx</code> <code>..</code> <code>end_idx</code>].  <a href="#a2c941abce41d90462e745ef6729e8965">More...</a><br /></td></tr>
<tr class="separator:a2c941abce41d90462e745ef6729e8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5368fbf40b74b98e7f24de59596e8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#aff5368fbf40b74b98e7f24de59596e8c">Slice99_sub_cast_type</a>(self,  start_idx,  end_idx,  T)</td></tr>
<tr class="memdesc:aff5368fbf40b74b98e7f24de59596e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#a2c941abce41d90462e745ef6729e8965" title="Subslicing self with [start_idx .. end_idx]. ">Slice99_sub</a> but explicitly casts <code>(self).item_size</code> to <code>T</code>.  <a href="#aff5368fbf40b74b98e7f24de59596e8c">More...</a><br /></td></tr>
<tr class="separator:aff5368fbf40b74b98e7f24de59596e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094655c210fc792711c1c61f2d205404"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a094655c210fc792711c1c61f2d205404">Slice99_advance</a>(self,  offset)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a64f9dee756ecea6812d186e85f549917">Slice99_advance_cast_type</a>(self, offset, size_t, size_t)</td></tr>
<tr class="memdesc:a094655c210fc792711c1c61f2d205404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances <code>self</code> by <code>offset</code> items.  <a href="#a094655c210fc792711c1c61f2d205404">More...</a><br /></td></tr>
<tr class="separator:a094655c210fc792711c1c61f2d205404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f9dee756ecea6812d186e85f549917"><td class="memItemLeft" align="right" valign="top"><a id="a64f9dee756ecea6812d186e85f549917"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a64f9dee756ecea6812d186e85f549917">Slice99_advance_cast_type</a>(self,  offset,  T,  U)&#160;&#160;&#160;<a class="el" href="slice99_8h.html#aff5368fbf40b74b98e7f24de59596e8c">Slice99_sub_cast_type</a>(self, offset, (U)(self).len, T)</td></tr>
<tr class="memdesc:a64f9dee756ecea6812d186e85f549917"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#a094655c210fc792711c1c61f2d205404" title="Advances self by offset items. ">Slice99_advance</a> but explicitly casts <code>(self).item_size</code> to <code>T</code> and <code>(self).len</code> to <code>U</code>. <br /></td></tr>
<tr class="separator:a64f9dee756ecea6812d186e85f549917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd148e62b60b316dfba5be120ef54c8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#acd148e62b60b316dfba5be120ef54c8a">Slice99_swap</a>(self,  lhs,  rhs,  backup)</td></tr>
<tr class="memdesc:acd148e62b60b316dfba5be120ef54c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the <code>lhs</code> -indexed and <code>rhs</code> -indexed items.  <a href="#acd148e62b60b316dfba5be120ef54c8a">More...</a><br /></td></tr>
<tr class="separator:acd148e62b60b316dfba5be120ef54c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b245f73d9eb540878d9b09c286c7a5d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a2b245f73d9eb540878d9b09c286c7a5d">Slice99_new</a> (void *ptr, size_t item_size, size_t len)</td></tr>
<tr class="memdesc:a2b245f73d9eb540878d9b09c286c7a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice.  <a href="#a2b245f73d9eb540878d9b09c286c7a5d">More...</a><br /></td></tr>
<tr class="separator:a2b245f73d9eb540878d9b09c286c7a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675d2dcf7501eddbc72e1863a230e11d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a675d2dcf7501eddbc72e1863a230e11d">Slice99_from_str</a> (char *str)</td></tr>
<tr class="memdesc:a675d2dcf7501eddbc72e1863a230e11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice from <code>str</code>.  <a href="#a675d2dcf7501eddbc72e1863a230e11d">More...</a><br /></td></tr>
<tr class="separator:a675d2dcf7501eddbc72e1863a230e11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd08534dacb5c17da008a55da5d438ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#acd08534dacb5c17da008a55da5d438ad">Slice99_from_ptrdiff</a> (void *start, void *end, size_t item_size)</td></tr>
<tr class="memdesc:acd08534dacb5c17da008a55da5d438ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a slice residing between <code>start</code> (inclusively) and <code>end</code> (exclusively).  <a href="#acd08534dacb5c17da008a55da5d438ad">More...</a><br /></td></tr>
<tr class="separator:acd08534dacb5c17da008a55da5d438ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1792fcd0cad249aeff742baa5cc65"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structSlice99.html">Slice99</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab3b1792fcd0cad249aeff742baa5cc65">Slice99_empty</a> (size_t item_size)</td></tr>
<tr class="memdesc:ab3b1792fcd0cad249aeff742baa5cc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty slice.  <a href="#ab3b1792fcd0cad249aeff742baa5cc65">More...</a><br /></td></tr>
<tr class="separator:ab3b1792fcd0cad249aeff742baa5cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f206fba3f90bec4ac7d520023e7dd0b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a9f206fba3f90bec4ac7d520023e7dd0b">Slice99_is_empty</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:a9f206fba3f90bec4ac7d520023e7dd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>self</code> is empty or not.  <a href="#a9f206fba3f90bec4ac7d520023e7dd0b">More...</a><br /></td></tr>
<tr class="separator:a9f206fba3f90bec4ac7d520023e7dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305e4878c540defdc9ed1ab987b4af98"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a305e4878c540defdc9ed1ab987b4af98">Slice99_size</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:a305e4878c540defdc9ed1ab987b4af98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a total size in bytes.  <a href="#a305e4878c540defdc9ed1ab987b4af98">More...</a><br /></td></tr>
<tr class="separator:a305e4878c540defdc9ed1ab987b4af98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d65ba55c6234dc8c1252ed323e0bbf"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a72d65ba55c6234dc8c1252ed323e0bbf">Slice99_first</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:a72d65ba55c6234dc8c1252ed323e0bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pointer to the first item.  <a href="#a72d65ba55c6234dc8c1252ed323e0bbf">More...</a><br /></td></tr>
<tr class="separator:a72d65ba55c6234dc8c1252ed323e0bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09bf811b7dbd399d8f08fdc0196932e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab09bf811b7dbd399d8f08fdc0196932e">Slice99_last</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:ab09bf811b7dbd399d8f08fdc0196932e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a pointer to the last item.  <a href="#ab09bf811b7dbd399d8f08fdc0196932e">More...</a><br /></td></tr>
<tr class="separator:ab09bf811b7dbd399d8f08fdc0196932e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0170af68a66bd469eff16c0fd5d503"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a6d0170af68a66bd469eff16c0fd5d503">Slice99_primitive_eq</a> (<a class="el" href="structSlice99.html">Slice99</a> lhs, <a class="el" href="structSlice99.html">Slice99</a> rhs)</td></tr>
<tr class="memdesc:a6d0170af68a66bd469eff16c0fd5d503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a byte-by-byte comparison of <code>lhs</code> with <code>rhs</code>.  <a href="#a6d0170af68a66bd469eff16c0fd5d503">More...</a><br /></td></tr>
<tr class="separator:a6d0170af68a66bd469eff16c0fd5d503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf32a71381185a03e3b50ed6179d7544"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#adf32a71381185a03e3b50ed6179d7544">Slice99_eq</a> (<a class="el" href="structSlice99.html">Slice99</a> lhs, <a class="el" href="structSlice99.html">Slice99</a> rhs, int(*comparator)(const void *, const void *))</td></tr>
<tr class="memdesc:adf32a71381185a03e3b50ed6179d7544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a comparison of <code>lhs</code> with <code>rhs</code> with a user-supplied comparator.  <a href="#adf32a71381185a03e3b50ed6179d7544">More...</a><br /></td></tr>
<tr class="separator:adf32a71381185a03e3b50ed6179d7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8c3986891a359399a136dfc7767254"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a5f8c3986891a359399a136dfc7767254">Slice99_primitive_starts_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> prefix)</td></tr>
<tr class="memdesc:a5f8c3986891a359399a136dfc7767254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>prefix</code> is a prefix of <code>self</code>, byte-by-byte.  <a href="#a5f8c3986891a359399a136dfc7767254">More...</a><br /></td></tr>
<tr class="separator:a5f8c3986891a359399a136dfc7767254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eec4a0a37bb2369b81ca7c91717091d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a1eec4a0a37bb2369b81ca7c91717091d">Slice99_starts_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> prefix, int(*comparator)(const void *, const void *))</td></tr>
<tr class="memdesc:a1eec4a0a37bb2369b81ca7c91717091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>prefix</code> is a prefix of <code>self</code> with a user-supplied comparator.  <a href="#a1eec4a0a37bb2369b81ca7c91717091d">More...</a><br /></td></tr>
<tr class="separator:a1eec4a0a37bb2369b81ca7c91717091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809060f1ae79857828eb7e41ae1f07ee"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a809060f1ae79857828eb7e41ae1f07ee">Slice99_primitive_ends_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> postfix)</td></tr>
<tr class="memdesc:a809060f1ae79857828eb7e41ae1f07ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>postfix</code> is a postfix of <code>self</code>, byte-by-byte.  <a href="#a809060f1ae79857828eb7e41ae1f07ee">More...</a><br /></td></tr>
<tr class="separator:a809060f1ae79857828eb7e41ae1f07ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdfc64cdb2e3b1e0842d98d38ea6faf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#adcdfc64cdb2e3b1e0842d98d38ea6faf">Slice99_ends_with</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> postfix, int(*comparator)(const void *, const void *))</td></tr>
<tr class="memdesc:adcdfc64cdb2e3b1e0842d98d38ea6faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code>postfix</code> is a postfix of <code>self</code> with a user-supplied comparator.  <a href="#adcdfc64cdb2e3b1e0842d98d38ea6faf">More...</a><br /></td></tr>
<tr class="separator:adcdfc64cdb2e3b1e0842d98d38ea6faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0633af9b428c3c28e0476c65c4bb5dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#af0633af9b428c3c28e0476c65c4bb5dc">Slice99_copy</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> other)</td></tr>
<tr class="memdesc:af0633af9b428c3c28e0476c65c4bb5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>other</code> to the beginning of <code>self</code>, byte-by-byte.  <a href="#af0633af9b428c3c28e0476c65c4bb5dc">More...</a><br /></td></tr>
<tr class="separator:af0633af9b428c3c28e0476c65c4bb5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e9856494623751a31202d2f1d94409"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#ab6e9856494623751a31202d2f1d94409">Slice99_copy_non_overlapping</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> other)</td></tr>
<tr class="memdesc:ab6e9856494623751a31202d2f1d94409"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#af0633af9b428c3c28e0476c65c4bb5dc" title="Copies other to the beginning of self, byte-by-byte. ">Slice99_copy</a> except that <code>self</code> and <code>other</code> shall be non-overlapping.  <a href="#ab6e9856494623751a31202d2f1d94409">More...</a><br /></td></tr>
<tr class="separator:ab6e9856494623751a31202d2f1d94409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314b3e238e23ad7486841d8a8ceb9e9e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a314b3e238e23ad7486841d8a8ceb9e9e">Slice99_fwrite</a> (<a class="el" href="structSlice99.html">Slice99</a> self, FILE *stream)</td></tr>
<tr class="memdesc:a314b3e238e23ad7486841d8a8ceb9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes <code>self</code> to <code>stream</code>, byte-by-byte.  <a href="#a314b3e238e23ad7486841d8a8ceb9e9e">More...</a><br /></td></tr>
<tr class="separator:a314b3e238e23ad7486841d8a8ceb9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aaf560a0ac60367ba665e8520ee544"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a84aaf560a0ac60367ba665e8520ee544">Slice99_write</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:a84aaf560a0ac60367ba665e8520ee544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes <code>self</code> to <code>stdout</code>, byte-by-byte.  <a href="#a84aaf560a0ac60367ba665e8520ee544">More...</a><br /></td></tr>
<tr class="separator:a84aaf560a0ac60367ba665e8520ee544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa61e5b059865b65048fce5dd53fea27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#afa61e5b059865b65048fce5dd53fea27">Slice99_fwrite_ln</a> (<a class="el" href="structSlice99.html">Slice99</a> self, FILE *stream)</td></tr>
<tr class="memdesc:afa61e5b059865b65048fce5dd53fea27"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#a314b3e238e23ad7486841d8a8ceb9e9e" title="Writes self to stream, byte-by-byte. ">Slice99_fwrite</a> but places a new line character afterwards.  <a href="#afa61e5b059865b65048fce5dd53fea27">More...</a><br /></td></tr>
<tr class="separator:afa61e5b059865b65048fce5dd53fea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c6aa8e9267ef6e0428764ab6028a9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#aa5c6aa8e9267ef6e0428764ab6028a9b">Slice99_write_ln</a> (<a class="el" href="structSlice99.html">Slice99</a> self)</td></tr>
<tr class="memdesc:aa5c6aa8e9267ef6e0428764ab6028a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="slice99_8h.html#a84aaf560a0ac60367ba665e8520ee544" title="Writes self to stdout, byte-by-byte. ">Slice99_write</a> but places a new line character afterwards.  <a href="#aa5c6aa8e9267ef6e0428764ab6028a9b">More...</a><br /></td></tr>
<tr class="separator:aa5c6aa8e9267ef6e0428764ab6028a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fa3f03cef49b60206d43abd5d02946"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a92fa3f03cef49b60206d43abd5d02946">Slice99_sort</a> (<a class="el" href="structSlice99.html">Slice99</a> self, int(*comparator)(const void *, const void *))</td></tr>
<tr class="memdesc:a92fa3f03cef49b60206d43abd5d02946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the items in <code>self</code>.  <a href="#a92fa3f03cef49b60206d43abd5d02946">More...</a><br /></td></tr>
<tr class="separator:a92fa3f03cef49b60206d43abd5d02946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc649fac630f1f611482f2d114f5a7e"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#acdc649fac630f1f611482f2d114f5a7e">Slice99_bsearch</a> (<a class="el" href="structSlice99.html">Slice99</a> self, const void *key, int(*comparator)(const void *, const void *))</td></tr>
<tr class="memdesc:acdc649fac630f1f611482f2d114f5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary search in <code>self</code>.  <a href="#acdc649fac630f1f611482f2d114f5a7e">More...</a><br /></td></tr>
<tr class="separator:acdc649fac630f1f611482f2d114f5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64763843fbfeea0099a7bae8a3fcd941"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a64763843fbfeea0099a7bae8a3fcd941">Slice99_swap_with_slice</a> (<a class="el" href="structSlice99.html">Slice99</a> self, <a class="el" href="structSlice99.html">Slice99</a> other, void *restrict backup)</td></tr>
<tr class="memdesc:a64763843fbfeea0099a7bae8a3fcd941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all the items in <code>self</code> with those in <code>other</code>.  <a href="#a64763843fbfeea0099a7bae8a3fcd941">More...</a><br /></td></tr>
<tr class="separator:a64763843fbfeea0099a7bae8a3fcd941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4ba9696f12fa0cf82fa018828e9a9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a51f4ba9696f12fa0cf82fa018828e9a9">Slice99_reverse</a> (<a class="el" href="structSlice99.html">Slice99</a> self, void *restrict backup)</td></tr>
<tr class="memdesc:a51f4ba9696f12fa0cf82fa018828e9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of items in <code>self</code>.  <a href="#a51f4ba9696f12fa0cf82fa018828e9a9">More...</a><br /></td></tr>
<tr class="separator:a51f4ba9696f12fa0cf82fa018828e9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292232b30f8add259cc03a87e5c96d86"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slice99_8h.html#a292232b30f8add259cc03a87e5c96d86">Slice99_split_at</a> (<a class="el" href="structSlice99.html">Slice99</a> self, size_t i, <a class="el" href="structSlice99.html">Slice99</a> *restrict lhs, <a class="el" href="structSlice99.html">Slice99</a> *restrict rhs)</td></tr>
<tr class="memdesc:a292232b30f8add259cc03a87e5c96d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>self</code> into two parts.  <a href="#a292232b30f8add259cc03a87e5c96d86">More...</a><br /></td></tr>
<tr class="separator:a292232b30f8add259cc03a87e5c96d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A slice of some array. </p>
<p>The macros <a class="el" href="slice99_8h.html#a29d489b28cf4d2cf56a17a2617990fee" title="Like assert. ">SLICE99_ASSERT</a>, <a class="el" href="slice99_8h.html#a4ad6e85e51121b718c704bc6f7c16cd7" title="Like memcmp. ">SLICE99_MEMCMP</a>, <a class="el" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c" title="Like memcpy. ">SLICE99_MEMCPY</a>, <a class="el" href="slice99_8h.html#afa5c9f55ad339be88c60744fadb239f6" title="Like memmove. ">SLICE99_MEMMOVE</a>, <a class="el" href="slice99_8h.html#a74ab39995ce273807783bb0006d9d85d" title="Like strlen. ">SLICE99_STRLEN</a>, <a class="el" href="slice99_8h.html#af75364d1b179202146fcf2953356d01a" title="Like qsort. ">SLICE99_QSORT</a>, and <a class="el" href="slice99_8h.html#aedee03b3135514dfcbdf244d01fa4d35" title="Like bsearch. ">SLICE99_BSEARCH</a> are automatically defined in case they have not been defined before including this header file. They represent the corresponding standard library's functions, though actual implementations can differ. If you develop software for a freestanding environment, these macros might need to be defined beforehand. Note that <a class="el" href="slice99_8h.html#af75364d1b179202146fcf2953356d01a" title="Like qsort. ">SLICE99_QSORT</a> and <a class="el" href="slice99_8h.html#aedee03b3135514dfcbdf244d01fa4d35" title="Like bsearch. ">SLICE99_BSEARCH</a> might need to be provided only if you define <code>SLICE99_INCLUDE_SORT</code> and <code>SLICE99_INCLUDE_BSEARCH</code>, respectively. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a094655c210fc792711c1c61f2d205404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094655c210fc792711c1c61f2d205404">&#9670;&nbsp;</a></span>Slice99_advance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_advance</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">offset&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a64f9dee756ecea6812d186e85f549917">Slice99_advance_cast_type</a>(self, offset, size_t, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances <code>self</code> by <code>offset</code> items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The original slice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The number of items to advance. Can be negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice advanced by <code>offset</code> items.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This subroutine is implemented as a macro due to the absence of a signed <code>size_t</code> counterpart (i.e. the offset can be negative).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>offset &lt;= (self).len</code> </dd></dl>

</div>
</div>
<a id="a907b544bdd92e9d7a7b3b50c69102fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907b544bdd92e9d7a7b3b50c69102fd6">&#9670;&nbsp;</a></span>Slice99_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_get</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="slice99_8h.html#a80df197030d2e328a1856a68204b7c0b">Slice99_get_cast_type</a>(self, i, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a pointer to the <code>i</code> -indexed item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice upon which the pointer will be computed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index of a desired item.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This subroutine is implemented as a macro due to the absence of a signed <code>size_t</code> counterpart (i.e. the index can be negative). </dd></dl>

</div>
</div>
<a id="a2c941abce41d90462e745ef6729e8965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c941abce41d90462e745ef6729e8965">&#9670;&nbsp;</a></span>Slice99_sub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_sub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">end_idx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="slice99_8h.html#aff5368fbf40b74b98e7f24de59596e8c">Slice99_sub_cast_type</a>(self, start_idx, end_idx, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subslicing <code>self</code> with [<code>start_idx</code> <code>..</code> <code>end_idx</code>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The original slice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_idx</td><td>The index at which a new slice will reside, inclusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_idx</td><td>The index at which a new slice will end, exclusively.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice with the aforementioned properties.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This subroutine is implemented as a macro due to the absence of a signed <code>size_t</code> counterpart (i.e. the indices can be negative).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>start_idx &lt;= end_idx</code> </dd></dl>

</div>
</div>
<a id="aff5368fbf40b74b98e7f24de59596e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5368fbf40b74b98e7f24de59596e8c">&#9670;&nbsp;</a></span>Slice99_sub_cast_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_sub_cast_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">end_idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code" href="slice99_8h.html#a29d489b28cf4d2cf56a17a2617990fee">SLICE99_ASSERT</a>((start_idx) &lt;= (end_idx)),                                                     \</div><div class="line">     Slice99_from_ptrdiff(                                                                         \</div><div class="line">         <a class="code" href="slice99_8h.html#a80df197030d2e328a1856a68204b7c0b">Slice99_get_cast_type</a>((<span class="keyword">self</span>), (start_idx), T),                                            \</div><div class="line">         <a class="code" href="slice99_8h.html#a80df197030d2e328a1856a68204b7c0b">Slice99_get_cast_type</a>((<span class="keyword">self</span>), (end_idx), T), (<span class="keyword">self</span>).item_size))</div><div class="ttc" id="slice99_8h_html_a29d489b28cf4d2cf56a17a2617990fee"><div class="ttname"><a href="slice99_8h.html#a29d489b28cf4d2cf56a17a2617990fee">SLICE99_ASSERT</a></div><div class="ttdeci">#define SLICE99_ASSERT</div><div class="ttdoc">Like assert. </div><div class="ttdef"><b>Definition:</b> slice99.h:55</div></div>
<div class="ttc" id="slice99_8h_html_a80df197030d2e328a1856a68204b7c0b"><div class="ttname"><a href="slice99_8h.html#a80df197030d2e328a1856a68204b7c0b">Slice99_get_cast_type</a></div><div class="ttdeci">#define Slice99_get_cast_type(self, i, T)</div><div class="ttdoc">The same as Slice99_get but explicitly casts (self).item_size to T. </div><div class="ttdef"><b>Definition:</b> slice99.h:238</div></div>
</div><!-- fragment -->
<p>The same as <a class="el" href="slice99_8h.html#a2c941abce41d90462e745ef6729e8965" title="Subslicing self with [start_idx .. end_idx]. ">Slice99_sub</a> but explicitly casts <code>(self).item_size</code> to <code>T</code>. </p>

</div>
</div>
<a id="acd148e62b60b316dfba5be120ef54c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd148e62b60b316dfba5be120ef54c8a">&#9670;&nbsp;</a></span>Slice99_swap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Slice99_swap</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">self, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lhs, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rhs, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">backup&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                                           \</div><div class="line">        SLICE99_ASSERT(backup);                                                                    <a class="code" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">\</a></div><div class="line"><a class="code" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">                                                                                                   \</a></div><div class="line"><a class="code" href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">        SLICE99_MEMCPY</a>((backup), <a class="code" href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6">Slice99_get</a>(<span class="keyword">self</span>, lhs), (<span class="keyword">self</span>).item_size);                        \</div><div class="line">        SLICE99_MEMCPY(<a class="code" href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6">Slice99_get</a>(<span class="keyword">self</span>, lhs), <a class="code" href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6">Slice99_get</a>(<span class="keyword">self</span>, rhs), (<span class="keyword">self</span>).item_size);          \</div><div class="line">        SLICE99_MEMCPY(<a class="code" href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6">Slice99_get</a>(<span class="keyword">self</span>, rhs), (backup), (<span class="keyword">self</span>).item_size);                        \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div><div class="ttc" id="slice99_8h_html_a7306a32a97b3b8a5f05c7b052618930c"><div class="ttname"><a href="slice99_8h.html#a7306a32a97b3b8a5f05c7b052618930c">SLICE99_MEMCPY</a></div><div class="ttdeci">#define SLICE99_MEMCPY</div><div class="ttdoc">Like memcpy. </div><div class="ttdef"><b>Definition:</b> slice99.h:67</div></div>
<div class="ttc" id="slice99_8h_html_a907b544bdd92e9d7a7b3b50c69102fd6"><div class="ttname"><a href="slice99_8h.html#a907b544bdd92e9d7a7b3b50c69102fd6">Slice99_get</a></div><div class="ttdeci">#define Slice99_get(self, i)</div><div class="ttdoc">Computes a pointer to the i -indexed item. </div><div class="ttdef"><b>Definition:</b> slice99.h:233</div></div>
</div><!-- fragment -->
<p>Swaps the <code>lhs</code> -indexed and <code>rhs</code> -indexed items. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The slice in which <code>lhs</code> and <code>rhs</code> will be swapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The index of the first item. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The index of the second item. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>The memory area of <code>self.item_size</code> bytes accessible for reading and writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This subroutine is implemented as a macro due to the absence of a signed <code>size_t</code> counterpart (i.e. the indices can be negative).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>backup != NULL</code> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acdc649fac630f1f611482f2d114f5a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc649fac630f1f611482f2d114f5a7e">&#9670;&nbsp;</a></span>Slice99_bsearch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* Slice99_bsearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a binary search in <code>self</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice in which the binary search will be performed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The value to search for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>A function returning the order of two items (0 if equal, &lt;0 if the first item is lesser than the second, &gt;0 if the first item is greater than the second).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an element in <code>self</code> that compares equal to <code>key</code>. If it does not exist, <code>NULL</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Included only if <code>SLICE99_INCLUDE_BSEARCH</code> is defined.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>comparator != NULL</code> </dd></dl>

</div>
</div>
<a id="af0633af9b428c3c28e0476c65c4bb5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0633af9b428c3c28e0476c65c4bb5dc">&#9670;&nbsp;</a></span>Slice99_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies <code>other</code> to the beginning of <code>self</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The location to which the whole <code>other</code> will be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The slice to be copied to <code>self</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6e9856494623751a31202d2f1d94409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e9856494623751a31202d2f1d94409">&#9670;&nbsp;</a></span>Slice99_copy_non_overlapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_copy_non_overlapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="slice99_8h.html#af0633af9b428c3c28e0476c65c4bb5dc" title="Copies other to the beginning of self, byte-by-byte. ">Slice99_copy</a> except that <code>self</code> and <code>other</code> shall be non-overlapping. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>self</code> and <code>other</code> shall be non-overlapping. </dd></dl>

</div>
</div>
<a id="ab3b1792fcd0cad249aeff742baa5cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b1792fcd0cad249aeff742baa5cc65">&#9670;&nbsp;</a></span>Slice99_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSlice99.html">Slice99</a> Slice99_empty </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>The value of <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99::item_size</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>item_size &gt; 0</code> </dd></dl>

</div>
</div>
<a id="adcdfc64cdb2e3b1e0842d98d38ea6faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdfc64cdb2e3b1e0842d98d38ea6faf">&#9670;&nbsp;</a></span>Slice99_ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>postfix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>postfix</code> is a postfix of <code>self</code> with a user-supplied comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>postfix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">postfix</td><td>The slice to be checked whether it is a postfix of <code>self</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>A function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>postfix</code> is a postfix of <code>self</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.item_size == postfix.item_size</code> </dd>
<dd>
<code>comparator != NULL</code> </dd></dl>

</div>
</div>
<a id="adf32a71381185a03e3b50ed6179d7544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf32a71381185a03e3b50ed6179d7544">&#9670;&nbsp;</a></span>Slice99_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a comparison of <code>lhs</code> with <code>rhs</code> with a user-supplied comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The first slice to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The second slice to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>A function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> and <code>rhs</code> are equal, <code>false</code> otherwise.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>lhs.item_size == rhs.item_size</code> </dd>
<dd>
<code>comparator != NULL</code> </dd></dl>

</div>
</div>
<a id="a72d65ba55c6234dc8c1252ed323e0bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d65ba55c6234dc8c1252ed323e0bbf">&#9670;&nbsp;</a></span>Slice99_first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* Slice99_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a pointer to the first item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice upon which the pointer will be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd08534dacb5c17da008a55da5d438ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd08534dacb5c17da008a55da5d438ad">&#9670;&nbsp;</a></span>Slice99_from_ptrdiff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSlice99.html">Slice99</a> Slice99_from_ptrdiff </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a slice residing between <code>start</code> (inclusively) and <code>end</code> (exclusively). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start position of a returned slice, inclusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end position of a returned slice, exlusively. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>The value of <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99::item_size</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>start != NULL</code> </dd>
<dd>
<code>end != NULL</code> </dd>
<dd>
<code>((char *)end - (char *)start) &gt;= 0</code> </dd>
<dd>
<code>(((char *)end - (char *)start)) % item_size == 0</code> </dd></dl>

</div>
</div>
<a id="a675d2dcf7501eddbc72e1863a230e11d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675d2dcf7501eddbc72e1863a230e11d">&#9670;&nbsp;</a></span>Slice99_from_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSlice99.html">Slice99</a> Slice99_from_str </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a slice from <code>str</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Any null-terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>str != NULL</code> </dd></dl>

</div>
</div>
<a id="a314b3e238e23ad7486841d8a8ceb9e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314b3e238e23ad7486841d8a8ceb9e9e">&#9670;&nbsp;</a></span>Slice99_fwrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_fwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes <code>self</code> to <code>stream</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>The stream to which <code>self</code> will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Included only if <code>SLICE99_INCLUDE_IO</code> is defined. </dd></dl>

</div>
</div>
<a id="afa61e5b059865b65048fce5dd53fea27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa61e5b059865b65048fce5dd53fea27">&#9670;&nbsp;</a></span>Slice99_fwrite_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_fwrite_ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="slice99_8h.html#a314b3e238e23ad7486841d8a8ceb9e9e" title="Writes self to stream, byte-by-byte. ">Slice99_fwrite</a> but places a new line character afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stream</td><td>The stream to which <code>self</code> will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Included only if <code>SLICE99_INCLUDE_IO</code> is defined. </dd></dl>

</div>
</div>
<a id="a9f206fba3f90bec4ac7d520023e7dd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f206fba3f90bec4ac7d520023e7dd0b">&#9670;&nbsp;</a></span>Slice99_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>self</code> is empty or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The checked slice.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>self</code> is empty, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="ab09bf811b7dbd399d8f08fdc0196932e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09bf811b7dbd399d8f08fdc0196932e">&#9670;&nbsp;</a></span>Slice99_last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* Slice99_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a pointer to the last item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice upon which the pointer will be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b245f73d9eb540878d9b09c286c7a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b245f73d9eb540878d9b09c286c7a5d">&#9670;&nbsp;</a></span>Slice99_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structSlice99.html">Slice99</a> Slice99_new </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The value of <a class="el" href="structSlice99.html#a1e583c6b18eb901fbe18a7872528c097" title="The pointer to data. ">Slice99::ptr</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item_size</td><td>The value of <a class="el" href="structSlice99.html#a9ef1a9b7b6645499fb2e1047b1c0228b" title="The size of each item in the array addressed by ptr. ">Slice99::item_size</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The value of <a class="el" href="structSlice99.html#af8b9efd5077f389a79eb0e902868ca1b" title="The count of items in the array addressed by ptr. ">Slice99::len</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>ptr != NULL</code> </dd>
<dd>
<code>item_size &gt; 0</code> </dd></dl>

</div>
</div>
<a id="a809060f1ae79857828eb7e41ae1f07ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809060f1ae79857828eb7e41ae1f07ee">&#9670;&nbsp;</a></span>Slice99_primitive_ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_primitive_ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>postfix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>postfix</code> is a postfix of <code>self</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>postfix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">postfix</td><td>The slice to be checked whether it is a postfix of <code>self</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>postfix</code> is a postfix of <code>self</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a6d0170af68a66bd469eff16c0fd5d503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0170af68a66bd469eff16c0fd5d503">&#9670;&nbsp;</a></span>Slice99_primitive_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_primitive_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a byte-by-byte comparison of <code>lhs</code> with <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The first slice to be compared. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The second slice to be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> and <code>rhs</code> are equal, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5f8c3986891a359399a136dfc7767254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8c3986891a359399a136dfc7767254">&#9670;&nbsp;</a></span>Slice99_primitive_starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_primitive_starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>prefix</code> is a prefix of <code>self</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>prefix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The slice to be checked whether it is a prefix of <code>self</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>prefix</code> is a prefix of <code>self</code>, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a id="a51f4ba9696f12fa0cf82fa018828e9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f4ba9696f12fa0cf82fa018828e9a9">&#9670;&nbsp;</a></span>Slice99_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of items in <code>self</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The slice to be reversed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>The memory area of <code>self.item_size</code> bytes accessible for reading and writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>backup != NULL</code> </dd></dl>

</div>
</div>
<a id="a305e4878c540defdc9ed1ab987b4af98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305e4878c540defdc9ed1ab987b4af98">&#9670;&nbsp;</a></span>Slice99_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t Slice99_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a total size in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice whose size is to be computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92fa3f03cef49b60206d43abd5d02946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fa3f03cef49b60206d43abd5d02946">&#9670;&nbsp;</a></span>Slice99_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the items in <code>self</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The slice whose items will be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>A function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Included only if <code>SLICE99_INCLUDE_SORT</code> is defined.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>comparator != NULL</code> </dd></dl>

</div>
</div>
<a id="a292232b30f8add259cc03a87e5c96d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292232b30f8add259cc03a87e5c96d86">&#9670;&nbsp;</a></span>Slice99_split_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_split_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a> *restrict&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a> *restrict&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits <code>self</code> into two parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be splitted into <code>lhs</code> and <code>rhs</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The index at which <code>self</code> will be splitted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lhs</td><td>The first part of <code>self</code> indexed as [0; <code>i</code>). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhs</td><td>The second part of <code>self</code> indexed as [<code>i</code>; <code>self.len</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>i &lt;= self.len</code> </dd>
<dd>
<code>lhs != NULL</code> </dd>
<dd>
<code>rhs != NULL</code> </dd></dl>

</div>
</div>
<a id="a1eec4a0a37bb2369b81ca7c91717091d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eec4a0a37bb2369b81ca7c91717091d">&#9670;&nbsp;</a></span>Slice99_starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Slice99_starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *, const void *)&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <code>prefix</code> is a prefix of <code>self</code> with a user-supplied comparator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be checked for <code>prefix</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>The slice to be checked whether it is a prefix of <code>self</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>A function deciding whether two items are equal ot not (0 if equal, any other value otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>prefix</code> is a prefix of <code>self</code>, otherwise <code>false</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.item_size == prefix.item_size</code> </dd>
<dd>
<code>comparator != NULL</code> </dd></dl>

</div>
</div>
<a id="a64763843fbfeea0099a7bae8a3fcd941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64763843fbfeea0099a7bae8a3fcd941">&#9670;&nbsp;</a></span>Slice99_swap_with_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_swap_with_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all the items in <code>self</code> with those in <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">self</td><td>The first slice to be swapped. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">other</td><td>The second slice to be swapped. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">backup</td><td>The memory area of <code>self.item_size</code> bytes accessible for reading and writing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>self.len == other.len</code> </dd>
<dd>
<code>self.item_size == other.item_size</code> </dd></dl>

</div>
</div>
<a id="a84aaf560a0ac60367ba665e8520ee544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84aaf560a0ac60367ba665e8520ee544">&#9670;&nbsp;</a></span>Slice99_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes <code>self</code> to <code>stdout</code>, byte-by-byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Included only if <code>SLICE99_INCLUDE_IO</code> is defined. </dd></dl>

</div>
</div>
<a id="aa5c6aa8e9267ef6e0428764ab6028a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c6aa8e9267ef6e0428764ab6028a9b">&#9670;&nbsp;</a></span>Slice99_write_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Slice99_write_ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSlice99.html">Slice99</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The same as <a class="el" href="slice99_8h.html#a84aaf560a0ac60367ba665e8520ee544" title="Writes self to stdout, byte-by-byte. ">Slice99_write</a> but places a new line character afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>The slice to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Included only if <code>SLICE99_INCLUDE_IO</code> is defined. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
